점근적 표기
성향을 찾아내는 것

1) 빅오 표기법
정의 : 자료의 개수가 많은 경우, 차수가 가장 큰 항이 절대적인 영향
ex) T(n) = n^2 + n -> n^2 영향이 99%

두개의 함수 f, g가 주어졌을 때, 모든 n에 대해 f <= g를 만족하는 상수가 존재하면 f = O(g(n))
A/B > 1 인것을 보이면 증명
증명만 하면 됨.
g(n)은 f(n)의 상한이다.
O(g(n))은 집합으로 생각할 수 있다.
O(n^2)  = { (3n^2+4n), (2n^2+2n), ... }
-> 계수를 고려하면 포함 가능
1000^n  < n! ? 이거 생각 좀
상한은 의미있는 걸 선택, 같은 차수가 상한으로써 의미가 있다.

2) 빅오메가 
3) 빅세타
동일한 함수로 상한과 하한을 만들 수 있는 경우

최선, 평균, 최악의 경우
실행시간은 입력 집합에 따라 다를 수 있다.
의미가 없는 경우가 많다.
평균의 경우 
계산하기가 상당히 어려움
최악의 경우 : 수행 시간이 가장 늦은 경우
계산하기 쉽고 응용에 따라서 중요한 의미를 가짐

예상 문제 
binaray search
최악의 경우 : log(n)

순환 알고리즘
반복 iteration
for, while 반복문
보통은 수행속도가 빠름, 문제에 따라 프로그램 작성이 어려울 수 있다.

순환 recursion
알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
-> 재귀함수, 스택 기능이 있다.
함수 호출의 오버헤드가 있다.
간결한 코딩이 가능

순환 알고리즘
알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
정의자체가 순환적으로 되어 있는 경우에 적합
팩토리얼 구하기 ex) n!, 피보나치 수열, 이항 계수, 하노이의 탑, 이진 탐색, ...
끝내주는 조건이 필요

하노이의 탑
일반적인 경우
어디에서 재귀가 일어나는가? 를 생각해바야함
순한으로 생각해야함
iteration으로 풀라고 하면 힘듦
-> 대부분의 순환은 반복으로 바꾸어 작성할 수 있음
팩퇴얼 문제의 경우 순환과 반복 알고리즘의 시간 복잡도는 O(n)으로 동일함.
ex) 이진 탐색, 퀵 정렬
* 복잡도 분석, 구현 모두 할 수 있어야 함.

연속 대치법
O(2^n)




