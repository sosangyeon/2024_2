점근적 표기
성향을 찾아내는 것

1) 빅오 표기법
정의 : 자료의 개수가 많은 경우, 차수가 가장 큰 항이 절대적인 영향
ex) T(n) = n^2 + n -> n^2 영향이 99%

두개의 함수 f, g가 주어졌을 때, 모든 n에 대해 f <= g를 만족하는 상수가 존재하면 f = O(g(n))
A/B > 1 인것을 보이면 증명
증명만 하면 됨.
g(n)은 f(n)의 상한이다.
O(g(n))은 집합으로 생각할 수 있다.
O(n^2)  = { (3n^2+4n), (2n^2+2n), ... }
-> 계수를 고려하면 포함 가능
1000^n  < n! ? 이거 생각 좀
상한은 의미있는 걸 선택, 같은 차수가 상한으로써 의미가 있다.

2) 빅오메가 
3) 빅세타
동일한 함수로 상한과 하한을 만들 수 있는 경우

최선, 평균, 최악의 경우
실행시간은 입력 집합에 따라 다를 수 있다.
의미가 없는 경우가 많다.
평균의 경우 
계산하기가 상당히 어려움
최악의 경우 : 수행 시간이 가장 늦은 경우
계산하기 쉽고 응용에 따라서 중요한 의미를 가짐

예상 문제 
binaray search
최악의 경우 : log(n)

순환 알고리즘
반복 iteration
for, while 반복문
보통은 수행속도가 빠름, 문제에 따라 프로그램 작성이 어려울 수 있다.

순환 recursion
알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
-> 재귀함수, 스택 기능이 있다.
함수 호출의 오버헤드가 있다.
간결한 코딩이 가능

순환 알고리즘
알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법
정의자체가 순환적으로 되어 있는 경우에 적합
팩토리얼 구하기 ex) n!, 피보나치 수열, 이항 계수, 하노이의 탑, 이진 탐색, ...
끝내주는 조건이 필요

하노이의 탑
일반적인 경우
어디에서 재귀가 일어나는가? 를 생각해바야함
순한으로 생각해야함
iteration으로 풀라고 하면 힘듦
-> 대부분의 순환은 반복으로 바꾸어 작성할 수 있음
팩퇴얼 문제의 경우 순환과 반복 알고리즘의 시간 복잡도는 O(n)으로 동일함.
ex) 이진 탐색, 퀵 정렬
* 복잡도 분석, 구현 모두 할 수 있어야 함.

연속 대치법
O(2^n)

2-2
인터프리터 방식 <> 컴파일 방식
인터프리터 : 런타임에 오류를 발생시킬 수 있다.
컴파일 : 실행 시간이 빠르다.

컴파일은 중간과정에 오류나는 부분을 확인할 수 있다. 
-> 실행이 안되니까

식별자로 숫자 0은 사용하지 않기

클래스 내부 함수를 숨기고 싶을 때, __init__(self):
literal : 프로그래밍 언어에서 고정된 데이터 값을 나타냄, 말그대로

파이썬에서 변수란
파이선에선 모든 자료가 클래스로부터 만들어진 객체
변수는 다른 객체를 참조하는 참조자 도는 포인터의 역할
동적 형결정 : 프로그램이 실행되는 과정에서 변수의 자료형이 결정되는 방식
-> 중간에 오버헤드가 발생 자유도가 많아서 꼬일수도

다른 변수여도 같은 리터럴을 가리키면 같은 id 값을 가지게 됨

list1 = [1,2,3]
list2 = [1,2,3]

print(list1 is list2) -> False
: print(list1 is list2)가 **False**를 출력하는 이유는 is 연산자가 **객체의 값이 아닌 메모리 주소(즉, 객체의 동일성)**를 비교하기 때문입니다.

input: str로 저장된다.
인풋 함수는 형변환을 고려해야한다.

튜플 
여러개를 반환할때 사용




